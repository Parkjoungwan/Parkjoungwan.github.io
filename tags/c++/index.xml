<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on kkeujeogblog</title>
    <link>https://parkjoungwan.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on kkeujeogblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Wed, 17 Mar 2021 16:59:05 +0900</lastBuildDate><atom:link href="https://parkjoungwan.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 6359 : 만취한 상범</title>
      <link>https://parkjoungwan.github.io/blog/nojam6359/</link>
      <pubDate>Wed, 17 Mar 2021 16:59:05 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam6359/</guid>
      <description>문제 테스트 케이스 T, 정수 N을 입력받는다.
N개의 감옥은 모두 잠겨있다.
그리고 1부터 N이 될 때까지 1씩 증가하며,
해당 값의 곱셈 값의 감옥문을 잠겼으면 열고 열렸으면 잠근다.
열려있는 감옥의 수를 구하라.
예제 2 5 100  출력 2 10  풀이 단순 구현문제로 볼 수 있는 문제다.
모든 감옥을 배열로 구현하고 위에서 시키는대로 열고 닫아도 시간 초과가 나지않는 걸로 보인다.
구현하다가 알게된 해법은 다음과 같다.
&amp;ldquo;N과 같거나 작은 제곱수의 감옥의 문이 열려있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2193 : 이친수</title>
      <link>https://parkjoungwan.github.io/blog/nojam2193/</link>
      <pubDate>Wed, 17 Mar 2021 16:51:45 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2193/</guid>
      <description>문제 간략하게 나타내면 다음과 같다.
이친수란, 다음의 규칙을 만족하는 이진수이다.
 이친수는 0으로 시작하지 않는다. 이친수는 1이 연속 두번으로 올 수 없다.  입력값 N이 주어졌을때, N자리 수의 이친수 개수를 구하자.
예제 3  출력 2  풀이 이 문제도 이전과 같은 DP 다이나믹 프로그래밍 문제이다.
내가 사용한 해법은 요약하면 다음과 같다.
&amp;ldquo;마지막 숫자가 0으로 끝나는 이친수는 0과 1을 붙일 수 있고, 마지막 숫자가 1로 끝나는 이친수는 0을 붙일 수 있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2156 : 포도주 시식</title>
      <link>https://parkjoungwan.github.io/blog/nojam2156/</link>
      <pubDate>Wed, 17 Mar 2021 13:51:30 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2156/</guid>
      <description>문제 간략화 하자면 다음과 같다.
 1번째 부터 n 까지의 숫자를 더할 것이다. 연속된 숫자는 2개까지 더할 수 있다. 위 규칙을 지키면서 만들 수 있는 최대의 숫자를 만들어라.  예제 6 6 10 13 9 8 1  출력 33  풀이 이 문제는 이전과 같은 DP 다이나믹 프로그래밍의 일종이다.
내가 사용한 해법을 최대한 요약하면 다음과 같다.
&amp;ldquo;각 최대값은 이전 최대값에 다음 수를 더해서 구할 수 있다. 4개 씩 끊어서 생각하자.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1912 : 연속합</title>
      <link>https://parkjoungwan.github.io/blog/nojam1912/</link>
      <pubDate>Sun, 14 Mar 2021 23:52:10 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1912/</guid>
      <description>문제 n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
입력 조건 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다.</description>
    </item>
    
  </channel>
</rss>
