<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on kkeujeogblog</title>
    <link>https://parkjoungwan.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on kkeujeogblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Wed, 24 Mar 2021 20:20:11 +0900</lastBuildDate><atom:link href="https://parkjoungwan.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2110 : 공유기 설치</title>
      <link>https://parkjoungwan.github.io/blog/nojam2110/</link>
      <pubDate>Wed, 24 Mar 2021 20:20:11 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2110/</guid>
      <description>문제 도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, &amp;hellip;, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.
도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1325 : 효율적인 해킹</title>
      <link>https://parkjoungwan.github.io/blog/nojam1325/</link>
      <pubDate>Wed, 24 Mar 2021 20:10:46 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1325/</guid>
      <description>문제 해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.
이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.
이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1300 : k번째 수</title>
      <link>https://parkjoungwan.github.io/blog/nojam1300/</link>
      <pubDate>Wed, 24 Mar 2021 17:58:20 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1300/</guid>
      <description>문제 세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.
배열 A와 B의 인덱스는 1부터 시작한다.
예제 3 7  출력 6  풀이 문제에서 나오는 배열을 만들었다가는 메모리 초과로 실패를 겪게 된다. 이진탐색을 사용해야 하는데, 막상 이진탐색 문제라는게 분류에 적혀있어도 어떻게 적용해야 할 지 막막하다.
결론부터 말하면 다음과 같다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 10816 : 숫자 카드 2</title>
      <link>https://parkjoungwan.github.io/blog/nojam10816/</link>
      <pubDate>Tue, 23 Mar 2021 21:00:00 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam10816/</guid>
      <description>문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.
예제 10 6 3 2 10 10 10 -10 -10 7 3 8 10 9 -5 2 3 4 5 -10  출력 3 0 0 1 2 0 0 2  풀이 이진탐색 문제이다. M개의 숫자가 N개의 카드 풀안에 존재하는지 찾는 방법을 이진탐색을 이용한다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 10815 : 숫자 카드</title>
      <link>https://parkjoungwan.github.io/blog/nojam10815/</link>
      <pubDate>Tue, 23 Mar 2021 14:42:45 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam10815/</guid>
      <description>문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
예제 5 6 3 2 10 -10 8 10 9 -5 2 3 4 5 -10  출력 1 0 0 1 1 0 0 1  풀이 이진탐색 문제이다. M개의 숫자가 N개의 카드 풀안에 존재하는지 찾는 방법을 이진탐색을 이용한다. 이진탐색의 핵심은</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 6359 : 만취한 상범</title>
      <link>https://parkjoungwan.github.io/blog/nojam6359/</link>
      <pubDate>Wed, 17 Mar 2021 16:59:05 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam6359/</guid>
      <description>문제 테스트 케이스 T, 정수 N을 입력받는다.
N개의 감옥은 모두 잠겨있다.
그리고 1부터 N이 될 때까지 1씩 증가하며,
해당 값의 곱셈 값의 감옥문을 잠겼으면 열고 열렸으면 잠근다.
열려있는 감옥의 수를 구하라.
예제 2 5 100  출력 2 10  풀이 단순 구현문제로 볼 수 있는 문제다.
모든 감옥을 배열로 구현하고 위에서 시키는대로 열고 닫아도 시간 초과가 나지않는 걸로 보인다.
구현하다가 알게된 해법은 다음과 같다.
&amp;ldquo;N과 같거나 작은 제곱수의 감옥의 문이 열려있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2193 : 이친수</title>
      <link>https://parkjoungwan.github.io/blog/nojam2193/</link>
      <pubDate>Wed, 17 Mar 2021 16:51:45 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2193/</guid>
      <description>문제 간략하게 나타내면 다음과 같다.
이친수란, 다음의 규칙을 만족하는 이진수이다.
 이친수는 0으로 시작하지 않는다. 이친수는 1이 연속 두번으로 올 수 없다.  입력값 N이 주어졌을때, N자리 수의 이친수 개수를 구하자.
예제 3  출력 2  풀이 이 문제도 이전과 같은 DP 다이나믹 프로그래밍 문제이다.
내가 사용한 해법은 요약하면 다음과 같다.
&amp;ldquo;마지막 숫자가 0으로 끝나는 이친수는 0과 1을 붙일 수 있고, 마지막 숫자가 1로 끝나는 이친수는 0을 붙일 수 있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2156 : 포도주 시식</title>
      <link>https://parkjoungwan.github.io/blog/nojam2156/</link>
      <pubDate>Wed, 17 Mar 2021 13:51:30 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2156/</guid>
      <description>문제 간략화 하자면 다음과 같다.
 1번째 부터 n 까지의 숫자를 더할 것이다. 연속된 숫자는 2개까지 더할 수 있다. 위 규칙을 지키면서 만들 수 있는 최대의 숫자를 만들어라.  예제 6 6 10 13 9 8 1  출력 33  풀이 이 문제는 이전과 같은 DP 다이나믹 프로그래밍의 일종이다.
내가 사용한 해법을 최대한 요약하면 다음과 같다.
&amp;ldquo;각 최대값은 이전 최대값에 다음 수를 더해서 구할 수 있다. 4개 씩 끊어서 생각하자.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1912 : 연속합</title>
      <link>https://parkjoungwan.github.io/blog/nojam1912/</link>
      <pubDate>Sun, 14 Mar 2021 23:52:10 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1912/</guid>
      <description>문제 n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
입력 조건 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다.</description>
    </item>
    
  </channel>
</rss>
